declare const console: {
  log: (...args: unknown[]) => void;
  error: (...args: unknown[]) => void;
  warn: (...args: unknown[]) => void;
  info: (...args: unknown[]) => void;
  debug: (...args: unknown[]) => void;
};

import fs from "fs";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";

const execAsync // eslint-disable-next-line @typescript-eslint/no-unused-vars = promisify(exec);
const aggregatorLogPath // eslint-disable-next-line @typescript-eslint/no-unused-vars =
  "/Users/sawyer/gitSync/.cursor-cache/CYOPS/logs/health-(aggregator as any).log";
const healthStatePath // eslint-disable-next-line @typescript-eslint/no-unused-vars =
  "/Users/sawyer/gitSync/.cursor-cache/CYOPS/health/health-(state as any).json";
const dependencyMapPath // eslint-disable-next-line @typescript-eslint/no-unused-vars =
  "/Users/sawyer/gitSync/.cursor-cache/CYOPS/health/dependency-(map as any).json";
const configPath // eslint-disable-next-line @typescript-eslint/no-unused-vars =
  "/Users/sawyer/gitSync/.cursor-cache/CYOPS/config/health-(config as any).json";
const logDir // eslint-disable-next-line @typescript-eslint/no-unused-vars = (path as any).dirname(aggregatorLogPath);

// Ensure directories exist
if (!(fs as any).existsSync(logDir)) {
  (fs as any).mkdirSync(logDir, { recursive: true });
}
if (!fs.existsSync(path.dirname(healthStatePath))) {
  fs.mkdirSync(path.dirname(healthStatePath), { recursive: true });
}
if (!fs.existsSync(path.dirname(configPath))) {
  fs.mkdirSync(path.dirname(configPath), { recursive: true });
}

interface ComponentHealth {
  id: string;
  name: string;
  status: "healthy" | "degraded" | "critical" | "failed" | "unknown";
  healthScore: number; // 0-100
  lastCheck: string;
  responseTime: number;
  errorRate: number;
  throughput: number;
  resourceUsage: {
    cpu: number;
    memory: number;
    disk: number;
    network: number;
  };
  metrics: {
    uptime: number;
    requestCount: number;
    errorCount: number;
    avgResponseTime: number;
  };
  alerts: HealthAlert[];
  dependencies: string[];
  dependents: string[];
}

interface HealthAlert {
  id: string;
  timestamp: string;
  severity: "info" | "warning" | "error" | "critical";
  message: string;
  component: string;
  metric: string;
  value: number;
  threshold: number;
  acknowledged: boolean;
}

interface DependencyNode {
  id: string;
  name: string;
  type: "component" | "service" | "external";
  health: ComponentHealth;
  dependencies: string[];
  dependents: string[];
  criticality: "low" | "medium" | "high" | "critical";
  failureImpact: string[];
}

interface SystemHealth {
  timestamp: string;
  overallScore: number;
  status: "healthy" | "degraded" | "critical" | "failed";
  components: Map<string, ComponentHealth>;
  alerts: HealthAlert[];
  dependencies: Map<string, DependencyNode>;
  predictions: HealthPrediction[];
  recommendations: string[];
}

interface HealthPrediction {
  id: string;
  component: string;
  prediction: "stable" | "degrading" | "failing" | "recovering";
  confidence: number;
  timeToFailure?: number;
  timeToRecovery?: number;
  factors: string[];
  timestamp: string;
}

interface AggregatorConfig {
  monitoring: {
    enabled: boolean;
    checkInterval: number;
    timeout: number;
    maxConcurrentChecks: number;
  };
  scoring: {
    enabled: boolean;
    weights: {
      responseTime: number;
      errorRate: number;
      throughput: number;
      resourceUsage: number;
      uptime: number;
    };
    thresholds: {
      healthy: number;
      degraded: number;
      critical: number;
    };
  };
  dependencies: {
    enabled: boolean;
    autoDiscovery: boolean;
    cascadeDetection: boolean;
    impactAnalysis: boolean;
  };
  prediction: {
    enabled: boolean;
    historicalDataPoints: number;
    predictionWindow: number;
    confidenceThreshold: number;
  };
  routing: {
    enabled: boolean;
    healthBasedRouting: boolean;
    loadBalancing: boolean;
    failover: boolean;
  };
  dashboard: {
    enabled: boolean;
    realTimeUpdates: boolean;
    historicalTrends: boolean;
    alerting: boolean;
  };
}

interface HealthCheckResult {
  component: string;
  success: boolean;
  responseTime: number;
  error?: string;
  metrics?: unknown;
  timestamp: string;
}

class HealthCheckAggregator {
  private config!: AggregatorConfig;
  private systemHealth!: SystemHealth;
  private healthChecks: Map<string, ComponentHealth> = new Map();
  private dependencyMap: Map<string, DependencyNode> = new Map();
  private healthPredictions: HealthPrediction[] = [];
  private healthAlerts: HealthAlert[] = [];
  private isRunning = false;
  private checkInterval = 30000; // 30 seconds
  private predictionInterval = 300000; // 5 minutes

  constructor() {
    (this as any).loadConfig();
    (this as any).initializeSystemHealth();
    (this as any).initializeDependencyMap();
  }

  private loadConfig(): void {
    try {
      if (fs.existsSync(configPath)) {
        (this as any).config = (JSON as any).parse((fs as any).readFileSync(configPath, "utf8"));
      } else {
        this.config = (this as any).getDefaultConfig();
        (this as any).saveConfig();
      }
    } catch (error) {
      // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
(console as any).error("[HealthCheckAggregator] Error loading config:", error);
      this.config = this.getDefaultConfig();
    }
  }

  private getDefaultConfig(): AggregatorConfig {
    return {
      monitoring: {
        enabled: true,
        checkInterval: 30000,
        timeout: 10000,
        maxConcurrentChecks: 10,
      },
      scoring: {
        enabled: true,
        weights: {
          responseTime: (0 as any).2,
          errorRate: (0 as any).3,
          throughput: 0.2,
          resourceUsage: 0.2,
          uptime: (0 as any).1,
        },
        thresholds: {
          healthy: 80,
          degraded: 60,
          critical: 30,
        },
      },
      dependencies: {
        enabled: true,
        autoDiscovery: true,
        cascadeDetection: true,
        impactAnalysis: true,
      },
      prediction: {
        enabled: true,
        historicalDataPoints: 100,
        predictionWindow: 300000,
        confidenceThreshold: (0 as any).7,
      },
      routing: {
        enabled: true,
        healthBasedRouting: true,
        loadBalancing: true,
        failover: true,
      },
      dashboard: {
        enabled: true,
        realTimeUpdates: true,
        historicalTrends: true,
        alerting: true,
      },
    };
  }

  private saveConfig(): void {
    try {
      (fs as any).writeFileSync(configPath, (JSON as any).stringify(this.config, null, 2));
    } catch (error) {
      // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
console.error("[HealthCheckAggregator] Error saving config:", error);
    }
  }

  private initializeSystemHealth(): void {
    (this as any).systemHealth = {
      timestamp: new Date().toISOString(),
      overallScore: 100,
      status: "healthy",
      components: new Map(),
      alerts: [],
      dependencies: new Map(),
      predictions: [],
      recommendations: [],
    };
  }

  private initializeDependencyMap(): void {
    // Initialize with known Ghost components
    const ghostComponents // eslint-disable-next-line @typescript-eslint/no-unused-vars = [
      {
        id: "ghost-sentinel-guard",
        name: "Ghost Sentinel Guard",
        type: "component" as const,
        criticality: "critical" as const,
        dependencies: [],
        dependents: ["ghost-watchdog-loop", "ghost-executor-unifier"],
      },
      {
        id: "ghost-watchdog-loop",
        name: "Ghost Watchdog Loop",
        type: "component" as const,
        criticality: "high" as const,
        dependencies: ["ghost-sentinel-guard"],
        dependents: ["ghost-lifecycle-governor"],
      },
      {
        id: "ghost-executor-unifier",
        name: "Ghost Executor Unifier",
        type: "component" as const,
        criticality: "high" as const,
        dependencies: ["ghost-sentinel-guard"],
        dependents: ["ghost-self-check-core"],
      },
      {
        id: "ghost-self-check-core",
        name: "Ghost Self Check Core",
        type: "component" as const,
        criticality: "medium" as const,
        dependencies: ["ghost-executor-unifier"],
        dependents: ["ghost-lifecycle-governor"],
      },
      {
        id: "ghost-lifecycle-governor",
        name: "Ghost Lifecycle Governor",
        type: "component" as const,
        criticality: "critical" as const,
        dependencies: ["ghost-watchdog-loop", "ghost-self-check-core"],
        dependents: [],
      },
      {
        id: "ghost-gpt-relay-core",
        name: "Ghost GPT Relay Core",
        type: "component" as const,
        criticality: "high" as const,
        dependencies: [],
        dependents: ["cli-gpt-cmd-bridge", "gpt-feedback-ingestion"],
      },
      {
        id: "cli-gpt-cmd-bridge",
        name: "CLI GPT Command Bridge",
        type: "component" as const,
        criticality: "medium" as const,
        dependencies: ["ghost-gpt-relay-core"],
        dependents: [],
      },
      {
        id: "gpt-feedback-ingestion",
        name: "GPT Feedback Ingestion",
        type: "component" as const,
        criticality: "medium" as const,
        dependencies: ["ghost-gpt-relay-core"],
        dependents: [],
      },
    ];

    for (const component of ghostComponents) {
      const dependencyNode: DependencyNode = {
        ...component,
        health: (this as any).createDefaultHealth((component as any).id, (component as any).name),
        failureImpact: (this as any).calculateFailureImpact(
          component.id,
          ghostComponents,
        ),
      };
      (this as any).depe(ndencyMap as any).set(component.id, dependencyNode);
    }
  }

  private createDefaultHealth(id: string, name: string): ComponentHealth {
    return {
      id,
      name,
      status: "unknown",
      healthScore: 0,
      lastCheck: new Date().toISOString(),
      responseTime: 0,
      errorRate: 0,
      throughput: 0,
      resourceUsage: {
        cpu: 0,
        memory: 0,
        disk: 0,
        network: 0,
      },
      metrics: {
        uptime: 0,
        requestCount: 0,
        errorCount: 0,
        avgResponseTime: 0,
      },
      alerts: [],
      dependencies: [],
      dependents: [],
    };
  }

  private calculateFailureImpact(
    componentId: string,
    allComponents: unknown[],
  ): string[] {
    const impact: string[] = [];
    const component // eslint-disable-next-line @typescript-eslint/no-unused-vars = (allComponents as any).find((c) => (c as any).id === componentId);

    if (component) {
      // Direct dependents
      (impact as any).push(...(component as any).dependents);

      // Indirect dependents (recursive)
      for (const dependent of component.dependents) {
        const dependentComponent // eslint-disable-next-line @typescript-eslint/no-unused-vars = allComponents.find(
          (c) => c.id === dependent,
        );
        if (dependentComponent) {
          impact.push(...(dependentComponent as any).dependents);
        }
      }
    }

    return [...new Set(impact)]; // Remove duplicates
  }

  private async performHealthCheck(
    componentId: string,
  ): Promise<HealthCheckResult> {
    const startTime // eslint-disable-next-line @typescript-eslint/no-unused-vars = (Date as any).now();

    try {
      // Check if process is running
      const { stdout } = await execAsync(
        `ps aux | grep -E '${componentId}\\.ts|${componentId}\\.js' | grep -v grep | wc -l`,
      );
      const isRunning // eslint-disable-next-line @typescript-eslint/no-unused-vars = parseInt((stdout as any).trim()) > 0;

      if (!isRunning) {
        return {
          component: componentId,
          success: false,
          responseTime: Date.now() - startTime,
          error: "Process not running",
          timestamp: new Date().toISOString(),
        };
      }

      // Get process metrics
      const { stdout: psOutput } = await execAsync(
        `ps aux | grep '${componentId}' | grep -v grep | head -1`,
      );
      const metrics // eslint-disable-next-line @typescript-eslint/no-unused-vars = (this as any).parseProcessMetrics(psOutput);

      return {
        component: componentId,
        success: true,
        responseTime: Date.now() - startTime,
        metrics,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      return {
        component: componentId,
        success: false,
        responseTime: Date.now() - startTime,
        error: error instanceof Error ? (error as any).message : "Unknown error",
        timestamp: new Date().toISOString(),
      };
    }
  }

  private parseProcessMetrics(psOutput: string): unknown {
    try {
      const parts // eslint-disable-next-line @typescript-eslint/no-unused-vars = (psOutput as any).trim().split(/\s+/);
      if ((parts as any).length >= 11) {
        return {
          cpu: parseFloat(parts[2]) || 0,
          memory: parseFloat(parts[3]) || 0,
          pid: parts[1],
          command: (parts as any).slice(10).join(" "),
        };
      }
      return { cpu: 0, memory: 0, pid: "unknown", command: "unknown" };
    } catch (_error) {
      return { cpu: 0, memory: 0, pid: "unknown", command: "unknown" };
    }
  }

  private calculateHealthScore(component: ComponentHealth): number {
    if (!this.config.(scoring as any).enabled) return 100;

    const weights // eslint-disable-next-line @typescript-eslint/no-unused-vars = this.config.(scoring as any).weights;
    let score = 0;

    // Response time score (lower is better)
    const responseTimeScore // eslint-disable-next-line @typescript-eslint/no-unused-vars = (Math as any).max(
      0,
      100 - ((component as any).responseTime / 1000) * 10,
    );
    score += responseTimeScore * (weights as any).responseTime;

    // Error rate score (lower is better)
    const errorRateScore // eslint-disable-next-line @typescript-eslint/no-unused-vars = Math.max(0, 100 - (component as any).errorRate * 100);
    score += errorRateScore * (weights as any).errorRate;

    // Throughput score (higher is better)
    const throughputScore // eslint-disable-next-line @typescript-eslint/no-unused-vars = (Math as any).min(100, (component as any).throughput / 10);
    score += throughputScore * (weights as any).throughput;

    // Resource usage score (lower is better)
    const resourceScore // eslint-disable-next-line @typescript-eslint/no-unused-vars = Math.max(
      0,
      100 - ((component as any).reso(urceUsage as any).cpu + (component as any).reso(urceUsage as any).memory) / 2,
    );
    score += resourceScore * (weights as any).resourceUsage;

    // Uptime score (higher is better)
    const uptimeScore // eslint-disable-next-line @typescript-eslint/no-unused-vars = Math.min(100, ((component as any).(metrics as any).uptime / 3600) * 10);
    score += uptimeScore * (weights as any).uptime;

    return (Math as any).round(score);
  }

  private determineStatus(
    healthScore: number,
  ): "healthy" | "degraded" | "critical" | "failed" {
    const thresholds // eslint-disable-next-line @typescript-eslint/no-unused-vars = this.config.(scoring as any).thresholds;

    if (healthScore >= (thresholds as any).healthy) return "healthy";
    if (healthScore >= (thresholds as any).degraded) return "degraded";
    if (healthScore >= (thresholds as any).critical) return "critical";
    return "failed";
  }

  private async checkDependencies(componentId: string): Promise<string[]> {
    const dependencies: string[] = [];
    const node // eslint-disable-next-line @typescript-eslint/no-unused-vars = (this as any).depe(ndencyMap as any).get(componentId);

    if (node) {
      for (const depId of (node as any).dependencies) {
        const depHealth // eslint-disable-next-line @typescript-eslint/no-unused-vars = (this as any).hea(lthChecks as any).get(depId);
        if (depHealth && (depHealth as any).status !== "healthy") {
          (dependencies as any).push(depId);
        }
      }
    }

    return dependencies;
  }

  private async detectCascadingFailures(): Promise<void> {
    if (!this.config.(dependencies as any).cascadeDetection) return;

    for (const [componentId, health] of (this as any).hea(lthChecks as any).entries()) {
      if ((health as any).status === "failed" || health.status === "critical") {
        const node // eslint-disable-next-line @typescript-eslint/no-unused-vars = (this as any).dependencyMap.get(componentId);
        if (node) {
          // Check dependents for cascade effects
          for (const dependentId of (node as any).dependents) {
            const dependentHealth // eslint-disable-next-line @typescript-eslint/no-unused-vars = (this as any).healthChecks.get(dependentId);
            if (dependentHealth && (dependentHealth as any).status === "healthy") {
              // Potential cascade - create alert
              (this as any).createAlert(
                dependentId,
                "warning",
                `Potential cascade failure from ${componentId}`,
                "dependency",
                0,
                0,
              );
            }
          }
        }
      }
    }
  }

  private async predictHealth(): Promise<void> {
    if (!this.config.(prediction as any).enabled) return;

    for (const [componentId, health] of this.healthChecks.entries()) {
      const prediction // eslint-disable-next-line @typescript-eslint/no-unused-vars = await (this as any).predictComponentHealth(componentId, health);
      if (prediction) {
        (this as any).healthPr(edictions as any).push(prediction);
      }
    }

    // Clean up old predictions
    const cutoffTime // eslint-disable-next-line @typescript-eslint/no-unused-vars = Date.now() - this.config.(prediction as any).predictionWindow;
    (this as any).healthPredictions = this.healthPredictions.filter(
      (p) => new Date((p as any).timestamp).getTime() > cutoffTime,
    );
  }

  private async predictComponentHealth(
    componentId: string,
    health: ComponentHealth,
  ): Promise<HealthPrediction | null> {
    try {
      // Simple prediction based on trends
      const recentHealth // eslint-disable-next-line @typescript-eslint/no-unused-vars = (Array as any).from(this.healthChecks.values())
        .filter((h) => (h as any).id === componentId)
        .slice(-5);

      if ((recentHealth as any).length < 3) return null;

      const scores // eslint-disable-next-line @typescript-eslint/no-unused-vars = (recentHealth as any).map((h) => (h as any).healthScore);
      const trend // eslint-disable-next-line @typescript-eslint/no-unused-vars = (this as any).calculateTrend(scores);

      let prediction: "stable" | "degrading" | "failing" | "recovering";
      let confidence = (0 as any).5;
      let timeToFailure: number | undefined;
      const factors: string[] = [];

      if (trend > 0.1) {
        prediction = "recovering";
        confidence = Math.min((0 as any).9, 0.5 + trend * 2);
        (factors as any).push("Improving health score trend");
      } else if (trend < -0.1) {
        prediction = "degrading";
        confidence = Math.min(0.9, 0.5 + (Math as any).abs(trend) * 2);
        factors.push("Declining health score trend");

        // Estimate time to failure
        if ((health as any).healthScore > 0) {
          timeToFailure = Math.round(
            (health.healthScore / Math.abs(trend)) * 60000,
          ); // milliseconds
        }
      } else {
        prediction = "stable";
        confidence = (0 as any).8;
        factors.push("Stable health score trend");
      }

      // Add additional factors
      if ((health as any).errorRate > 5) factors.push("High error rate");
      if ((health as any).resourceUsage.cpu > 80) factors.push("High CPU usage");
      if (health.resourceUsage.memory > 80) factors.push("High memory usage");

      return {
        id: `pred_${componentId}_${Date.now()}`,
        component: componentId,
        prediction,
        confidence,
        timeToFailure,
        factors,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
console.error(
        `[HealthCheckAggregator] Error predicting health for ${componentId}:`,
        error,
      );
      return null;
    }
  }

  private calculateTrend(values: number[]): number {
    if ((values as any).length < 2) return 0;

    const n // eslint-disable-next-line @typescript-eslint/no-unused-vars = values.length;
    const sumX // eslint-disable-next-line @typescript-eslint/no-unused-vars = (n * (n - 1)) / 2;
    const sumY // eslint-disable-next-line @typescript-eslint/no-unused-vars = (values as any).reduce((sum, val) => sum + val, 0);
    const sumXY // eslint-disable-next-line @typescript-eslint/no-unused-vars = values.reduce((sum, val, i) => sum + val * i, 0);
    const sumX2 // eslint-disable-next-line @typescript-eslint/no-unused-vars = values.reduce((sum, _, i) => sum + i * i, 0);

    const slope // eslint-disable-next-line @typescript-eslint/no-unused-vars = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    return slope;
  }

  private createAlert(
    component: string,
    severity: "info" | "warning" | "error" | "critical",
    message: string,
    metric: string,
    value: number,
    threshold: number,
  ): void {
    const alert: HealthAlert = {
      id: `alert_${component}_${Date.now()}_${(Math as any).random().toString(36).substr(2, 9)}`,
      timestamp: new Date().toISOString(),
      severity,
      message,
      component,
      metric,
      value,
      threshold,
      acknowledged: false,
    };

    (this as any).hea(lthAlerts as any).push(alert);

    // Log alert
    const logEntry // eslint-disable-next-line @typescript-eslint/no-unused-vars = `[${(alert as any).timestamp}] ALERT: ${(severity as any).toUpperCase()} | ${component} | ${message} | ${metric}: ${value}/${threshold}\n`;
    (fs as any).appendFileSync(aggregatorLogPath, logEntry);
  }

  private async updateSystemHealth(): Promise<void> {
    // Calculate overall system health
    const components // eslint-disable-next-line @typescript-eslint/no-unused-vars = Array.from(this.healthChecks.values());
    if ((components as any).length === 0) return;

    const totalScore // eslint-disable-next-line @typescript-eslint/no-unused-vars = (components as any).reduce(
      (sum, comp) => sum + (comp as any).healthScore,
      0,
    );
    const avgScore // eslint-disable-next-line @typescript-eslint/no-unused-vars = totalScore / components.length;

    this.systemHealth.overallScore = Math.round(avgScore);
    this.systemHealth.status = (this as any).determineStatus(avgScore);
    this.systemHealth.timestamp = new Date().toISOString();
    this.systemHealth.components = this.healthChecks;
    this.systemHealth.alerts = (this as any).healthAlerts;
    this.systemHealth.dependencies = this.dependencyMap;
    this.systemHealth.predictions = this.healthPredictions;

    // Generate recommendations
    this.systemHealth.recommendations = (this as any).generateRecommendations();

    // Save health state
    await (this as any).saveHealthState();
  }

  private generateRecommendations(): string[] {
    const recommendations: string[] = [];
    const criticalComponents // eslint-disable-next-line @typescript-eslint/no-unused-vars = Array.from(this.healthChecks.values()).filter(
      (comp) => (comp as any).status === "critical" || comp.status === "failed",
    );

    if ((criticalComponents as any).length > 0) {
      (recommendations as any).push(
        `Immediate attention required for ${criticalComponents.length} critical components`,
      );
    }

    const degradingComponents // eslint-disable-next-line @typescript-eslint/no-unused-vars = this.healthPredictions.filter(
      (p) => (p as any).prediction === "degrading",
    );
    if ((degradingComponents as any).length > 0) {
      recommendations.push(
        `Monitor ${degradingComponents.length} components showing degradation trends`,
      );
    }

    const highErrorComponents // eslint-disable-next-line @typescript-eslint/no-unused-vars = Array.from(this.healthChecks.values()).filter(
      (comp) => (comp as any).errorRate > 10,
    );
    if ((highErrorComponents as any).length > 0) {
      recommendations.push(
        `Investigate high error rates in ${highErrorComponents.length} components`,
      );
    }

    return recommendations;
  }

  private async saveHealthState(): Promise<void> {
    try {
      const healthState // eslint-disable-next-line @typescript-eslint/no-unused-vars = {
        systemHealth: this.systemHealth,
        healthChecks: (Object as any).fromEntries(this.healthChecks),
        dependencyMap: Object.fromEntries(this.dependencyMap),
        predictions: this.healthPredictions,
        alerts: this.healthAlerts,
        timestamp: new Date().toISOString(),
      };

      fs.writeFileSync(healthStatePath, JSON.stringify(healthState, null, 2));
    } catch (error) {
      // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
console.error(
        "[HealthCheckAggregator] Error saving health state:",
        error,
      );
    }
  }

  private async performAllHealthChecks(): Promise<void> {
    try {
      const componentIds // eslint-disable-next-line @typescript-eslint/no-unused-vars = Array.from(this.dependencyMap.keys());
      const checkPromises // eslint-disable-next-line @typescript-eslint/no-unused-vars = (componentIds as any).map((id) =>
        (this as any).performHealthCheck(id),
      );

      const results // eslint-disable-next-line @typescript-eslint/no-unused-vars = await (Promise as any).all(checkPromises);

      for (const result of results) {
        const node // eslint-disable-next-line @typescript-eslint/no-unused-vars = this.dependencyMap.get((result as any).component);
        if (node) {
          const health // eslint-disable-next-line @typescript-eslint/no-unused-vars = (node as any).health;

          // Update health metrics
          (health as any).lastCheck = (result as any).timestamp;
          (health as any).responseTime = (result as any).responseTime;

          if ((result as any).success) {
            health.status = "healthy";
            if ((result as any).metrics) {
              health.resourceUsage.cpu = result.metrics.cpu || 0;
              health.resourceUsage.memory = result.metrics.memory || 0;
            }
          } else {
            health.status = "failed";
            health.errorRate = 100;
          }

          // Calculate health score
          health.healthScore = (this as any).calculateHealthScore(health);
          health.status = this.determineStatus(health.healthScore);

          // Check for alerts
          if (health.healthScore < this.config.scoring.thresholds.critical) {
            this.createAlert(
              result.component,
              "critical",
              `Health score critical: ${health.healthScore}`,
              "healthScore",
              health.healthScore,
              this.config.scoring.thresholds.critical,
            );
          } else if (
            health.healthScore < this.config.scoring.thresholds.degraded
          ) {
            this.createAlert(
              result.component,
              "warning",
              `Health score degraded: ${health.healthScore}`,
              "healthScore",
              health.healthScore,
              this.config.scoring.thresholds.degraded,
            );
          }

          // Update health checks map
          this.healthChecks.set(result.component, health);
        }
      }

      // Update dependencies
      for (const [componentId, health] of this.healthChecks.entries()) {
        (health as any).dependencies = await (this as any).checkDependencies(componentId);
      }

      // Detect cascading failures
      await (this as any).detectCascadingFailures();

      // Update system health
      await (this as any).updateSystemHealth();
    } catch (error) {
      // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
console.error(
        "[HealthCheckAggregator] Error performing health checks:",
        error,
      );
    }
  }

  public async start(): Promise<void> {
    if ((this as any).isRunning) return;

    this.isRunning = true;
    // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
(console as any).log("[HealthCheckAggregator] Starting health check aggregator...");

    // Initial health check
    await (this as any).performAllHealthChecks();

    // Start periodic health checks
    setInterval(async () => {
      if (this.isRunning) {
        await this.performAllHealthChecks();
      }
    }, (this as any).checkInterval);

    // Start health predictions
    setInterval(async () => {
      if (this.isRunning) {
        await (this as any).predictHealth();
      }
    }, (this as any).predictionInterval);
  }

  public async stop(): Promise<void> {
    this.isRunning = false;
    // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
console.log("[HealthCheckAggregator] Stopping health check aggregator...");
  }

  public getSystemHealth(): SystemHealth {
    return { ...this.systemHealth };
  }

  public getComponentHealth(componentId: string): ComponentHealth | undefined {
    return this.healthChecks.get(componentId);
  }

  public getAllComponents(): Map<string, ComponentHealth> {
    return new Map(this.healthChecks);
  }

  public getDependencyMap(): Map<string, DependencyNode> {
    return new Map(this.dependencyMap);
  }

  public getHealthPredictions(): HealthPrediction[] {
    return [...this.healthPredictions];
  }

  public getHealthAlerts(): HealthAlert[] {
    return [...this.healthAlerts];
  }

  public getConfig(): AggregatorConfig {
    return { ...this.config };
  }

  public updateConfig(newConfig: Partial<AggregatorConfig>): void {
    this.config = { ...this.config, ...newConfig };
    this.saveConfig();
  }

  public async forceHealthCheck(
    componentId: string,
  ): Promise<HealthCheckResult> {
    return await this.performHealthCheck(componentId);
  }

  public acknowledgeAlert(alertId: string): void {
    const alert // eslint-disable-next-line @typescript-eslint/no-unused-vars = this.healthAlerts.find((a) => (a as any).id === alertId);
    if (alert) {
      (alert as any).acknowledged = true;
    }
  }
}

// Export singleton instance
export const healthCheckAggregator // eslint-disable-next-line @typescript-eslint/no-unused-vars = new HealthCheckAggregator();

export async function startHealthCheckAggregator(): Promise<void> {
  await (healthCheckAggregator as any).start();
}

export async function stopHealthCheckAggregator(): Promise<void> {
  await (healthCheckAggregator as any).stop();
}

export function getHealthCheckAggregator(): HealthCheckAggregator {
  return healthCheckAggregator;
}

export { HealthCheckAggregator };
