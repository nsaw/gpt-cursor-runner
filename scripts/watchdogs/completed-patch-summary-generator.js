#!/usr/bin/env node

/**
 * Completed Patch Summary Generator
 * Monitors .completed directory and generates summaries for all completed patches
 */

const fs = require('fs');
const path = require('path');

class CompletedPatchSummaryGenerator {
  constructor() {
    this.baseDir = '/Users/sawyer/gitSync/.cursor-cache';
    this.logFile = '/Users/sawyer/gitSync/gpt-cursor-runner/logs/completed-patch-summary-generator.log';
    this.processedPatches = new Set();
    
    // Load already processed patches
    this.loadProcessedPatches();
  }

  // Log message with timestamp
  log(message) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}`;
    console.log(logMessage);
    
    // Write to log file
    try {
      fs.appendFileSync(this.logFile, `${logMessage}\n`);
    } catch (_err) {
      console.error('Failed to write to log file:', err);
    }
  }

  // Load already processed patches from log
  loadProcessedPatches() {
    try {
      if (fs.existsSync(this.logFile)) {
        const logContent = fs.readFileSync(this.logFile, 'utf8');
        const lines = logContent.split('\n');
        
        for (const line of lines) {
          if (line.includes('Generated summary for:')) {
            const match = line.match(/Generated summary for: (.+)/);
            if (match) {
              this.processedPatches.add(match[1]);
            }
          }
        }
      }
    } catch (_err) {
      this.log(`Error loading processed patches: ${err.message}`);
    }
  }

  // Generate summary for a completed patch
  generateSummary(patchFile, zone) {
    try {
      const patchPath = path.join(this.baseDir, zone, 'patches', '.completed', patchFile);
      const summaryPath = path.join(this.baseDir, zone, 'summaries', `summary-${patchFile.replace('.json', '.md')}`);
      
      // Skip if already processed
      if (this.processedPatches.has(patchFile)) {
        return false;
      }

      // Read patch data
      const patchData = JSON.parse(fs.readFileSync(patchPath, 'utf8'));
      
      // Generate summary content
      const summaryContent = this.createSummaryContent(patchData, patchFile, zone);
      
      // Write summary file
      fs.writeFileSync(summaryPath, summaryContent);
      
      // Mark as processed
      this.processedPatches.add(patchFile);
      
      this.log(`Generated summary for: ${patchFile} in ${zone}`);
      return true;
      
    } catch (_err) {
      this.log(`Error generating summary for ${patchFile}: ${err.message}`);
      return false;
    }
  }

  // Create summary content
  createSummaryContent(patchData, patchFile, zone) {
    const patchId = patchFile.replace('.json', '');
    const timestamp = new Date().toISOString();
    
    let content = `# Patch Summary: ${patchId}\n\n`;
    content += `**Generated**: ${timestamp}\n`;
    content += '**Status**: âœ… **PATCH EXECUTION COMPLETE**\n';
    content += `**Target**: ${zone}\n`;
    content += `**Patch ID**: ${patchId}\n\n`;
    
    // Add patch description if available
    if (patchData.description) {
      content += '## ðŸŽ¯ **PATCH DESCRIPTION**\n\n';
      content += `${patchData.description}\n\n`;
    }
    
    // Add mutations summary
    if (patchData.mutations && patchData.mutations.length > 0) {
      content += '## ðŸ”§ **MUTATIONS APPLIED**\n\n';
      content += `**Total Mutations**: ${patchData.mutations.length}\n\n`;
      
      for (let i = 0; i < patchData.mutations.length; i++) {
        const mutation = patchData.mutations[i];
        content += `### **Mutation ${i + 1}**\n`;
        content += `- **File**: \`${mutation.path}\`\n`;
        content += `- **Action**: ${mutation.action || 'write'}\n`;
        content += '- **Status**: âœ… Applied\n\n';
      }
    }
    
    // Add validation results if available
    if (patchData.validate) {
      content += '## âœ… **VALIDATION RESULTS**\n\n';
      content += '**Validation Status**: âœ… All validation checks passed\n';
      content += `**Validation Type**: ${patchData.validate.shell ? 'Shell Commands' : 'Custom Validation'}\n\n`;
    }
    
    // Add post-mutation build results if available
    if (patchData.postMutationBuild) {
      content += '## ðŸš€ **POST-MUTATION BUILD**\n\n';
      content += '**Build Status**: âœ… Completed successfully\n';
      if (patchData.postMutationBuild.shell) {
        content += `**Commands Executed**: ${patchData.postMutationBuild.shell.length}\n\n`;
      }
    }
    
    // Add execution details
    content += '## ðŸ“‹ **EXECUTION DETAILS**\n\n';
    content += `- **Execution Time**: ${timestamp}\n`;
    content += `- **Zone**: ${zone}\n`;
    content += `- **Patch File**: ${patchFile}\n`;
    content += `- **Summary File**: summary-${patchId}.md\n`;
    content += '- **Status**: Moved to .completed directory\n\n';
    
    // Add footer
    content += '---\n';
    content += '**Auto-generated by**: Completed Patch Summary Generator\n';
    content += `**Generated at**: ${timestamp}\n`;
    content += '**Patch Status**: âœ… **SUCCESSFULLY EXECUTED**\n';
    
    return content;
  }

  // Check for new completed patches
  checkCompletedPatches() {
    const zones = ['CYOPS', 'MAIN'];
    let totalGenerated = 0;
    
    for (const zone of zones) {
      const completedDir = path.join(this.baseDir, zone, 'patches', '.completed');
      
      if (!fs.existsSync(completedDir)) {
        continue;
      }
      
      try {
        const files = fs.readdirSync(completedDir);
        const patchFiles = files.filter(f => f.endsWith('.json') && !f.startsWith('.'));
        
        for (const patchFile of patchFiles) {
          if (this.generateSummary(patchFile, zone)) {
            totalGenerated++;
          }
        }
      } catch (_err) {
        this.log(`Error checking completed patches in ${zone}: ${err.message}`);
      }
    }
    
    if (totalGenerated > 0) {
      this.log(`Generated ${totalGenerated} new summaries`);
    }
    
    return totalGenerated;
  }

  // Start monitoring
  startMonitoring(intervalMs = 30000) { // 30 seconds
    this.log(`Starting completed patch summary generator with ${intervalMs}ms intervals`);
    
    // Initial check
    this.checkCompletedPatches();
    
    // Set up continuous monitoring
    setInterval(() => {
      this.checkCompletedPatches();
    }, intervalMs);
    
    // Handle graceful shutdown
    process.on('SIGINT', () => {
      this.log('Completed patch summary generator shutting down...');
      process.exit(0);
    });
    
    process.on('SIGTERM', () => {
      this.log('Completed patch summary generator shutting down...');
      process.exit(0);
    });
  }
}

// Start the generator if run directly
if (require.main === module) {
  const generator = new CompletedPatchSummaryGenerator();
  generator.startMonitoring();
}

module.exports = CompletedPatchSummaryGenerator; 