#!/bin/bash
set -euo pipefail

# Command Queue Daemon per COACH spec
# Watches /commands/, uses systemd-run, logs to summaries

COMMANDS_DIR="/Users/sawyer/gitSync/gpt-cursor-runner/commands"
SUMMARIES_DIR="/Users/sawyer/gitSync/.cursor-cache/CYOPS/summaries"
LOG_FILE="/Users/sawyer/gitSync/.cursor-cache/CYOPS/patches/.logs/command-queue-daemon.log"
PID_FILE="/Users/sawyer/gitSync/gpt-cursor-runner/pids/command-queue-daemon.pid"

# Ensure directories exist
mkdir -p "$COMMANDS_DIR"
mkdir -p "$SUMMARIES_DIR"
mkdir -p "$(dirname "$LOG_FILE")"
mkdir -p "$(dirname "$PID_FILE")"

function log_message() {
  echo "[$(date)] $1" >> "$LOG_FILE"
}

function log_summary() {
  local summary_file="$SUMMARIES_DIR/summary-command-queue-$(date +%Y%m%d_%H%M%S).md"
  cat > "$summary_file" << EOF
# Summary: Command Queue Daemon Event

**Event Time**: $(date)  
**Status**: $1  
**Roadmap Phase**: Command Processing  

## Event Details
$2

## Command Queue Status
- **Commands Directory**: $COMMANDS_DIR
- **Active Commands**: $(ls -1 "$COMMANDS_DIR"/*.cmd 2>/dev/null | wc -l | tr -d ' ')
- **Processed Commands**: $(ls -1 "$COMMANDS_DIR"/*.completed 2>/dev/null | wc -l | tr -d ' ')
- **Failed Commands**: $(ls -1 "$COMMANDS_DIR"/*.failed 2>/dev/null | wc -l | tr -d ' ')

## System Status
- **Daemon PID**: $(cat "$PID_FILE" 2>/dev/null || echo "Not running")
- **Uptime**: $(ps -p $(cat "$PID_FILE" 2>/dev/null) -o etime= 2>/dev/null || echo "Unknown")

---
*Generated by Command Queue Daemon*
EOF
}

function process_command() {
  local cmd_file="$1"
  local cmd_name=$(basename "$cmd_file" .cmd)
  local cmd_content=$(cat "$cmd_file")
  
  log_message "Processing command: $cmd_name"
  log_summary "PROCESSING" "Processing command: $cmd_name\n\nContent:\n\`\`\`\n$cmd_content\n\`\`\`"
  
  # Move command to processing state
  mv "$cmd_file" "${cmd_file}.processing"
  
  # Execute command using systemd-run (or equivalent on macOS)
  local exit_code=0
  local output=""
  
  if command -v systemd-run >/dev/null 2>&1; then
    # Linux systemd-run
    output=$(systemd-run --user --scope bash -c "$cmd_content" 2>&1)
    exit_code=$?
  else
    # macOS equivalent - use launchctl or direct execution
    output=$(bash -c "$cmd_content" 2>&1)
    exit_code=$?
  fi
  
  # Move to appropriate final state
  if [ $exit_code -eq 0 ]; then
    mv "${cmd_file}.processing" "${cmd_file}.completed"
    log_message "Command completed successfully: $cmd_name"
    log_summary "COMPLETED" "Command completed successfully: $cmd_name\n\nOutput:\n\`\`\`\n$output\n\`\`\`"
  else
    mv "${cmd_file}.processing" "${cmd_file}.failed"
    log_message "Command failed: $cmd_name (exit code: $exit_code)"
    log_summary "FAILED" "Command failed: $cmd_name\n\nExit Code: $exit_code\n\nOutput:\n\`\`\`\n$output\n\`\`\`"
  fi
}

function cleanup_old_files() {
  # Clean up files older than 24 hours
  find "$COMMANDS_DIR" -name "*.completed" -mtime +1 -delete 2>/dev/null || true
  find "$COMMANDS_DIR" -name "*.failed" -mtime +1 -delete 2>/dev/null || true
  find "$COMMANDS_DIR" -name "*.processing" -mtime +1 -delete 2>/dev/null || true
}

function health_check() {
  # Check if daemon is healthy
  if [ ! -f "$PID_FILE" ]; then
    return 1
  fi
  
  local pid=$(cat "$PID_FILE")
  if ! ps -p "$pid" >/dev/null 2>&1; then
    return 1
  fi
  
  return 0
}

function start_daemon() {
  log_message "üöÄ Starting Command Queue Daemon..."
  log_summary "STARTUP" "Command Queue Daemon starting up"
  
  # Write PID file
  echo $$ > "$PID_FILE"
  
  # Initial cleanup
  cleanup_old_files
  
  # Main monitoring loop
  while true; do
    # Check for new .cmd files
    for cmd_file in "$COMMANDS_DIR"/*.cmd; do
      if [ -f "$cmd_file" ]; then
        process_command "$cmd_file"
      fi
    done
    
    # Cleanup old files every hour
    if [ $(( $(date +%s) % 3600 )) -lt 60 ]; then
      cleanup_old_files
    fi
    
    # Sleep for 5 seconds
    sleep 5
  done
}

function stop_daemon() {
  log_message "üõë Stopping Command Queue Daemon..."
  log_summary "SHUTDOWN" "Command Queue Daemon shutting down"
  
  if [ -f "$PID_FILE" ]; then
    local pid=$(cat "$PID_FILE")
    kill "$pid" 2>/dev/null || true
    rm -f "$PID_FILE"
  fi
}

function status() {
  if health_check; then
    echo "‚úÖ Command Queue Daemon is running"
    echo "PID: $(cat "$PID_FILE")"
    echo "Commands Directory: $COMMANDS_DIR"
    echo "Active Commands: $(ls -1 "$COMMANDS_DIR"/*.cmd 2>/dev/null | wc -l | tr -d ' ')"
    echo "Completed Commands: $(ls -1 "$COMMANDS_DIR"/*.completed 2>/dev/null | wc -l | tr -d ' ')"
    echo "Failed Commands: $(ls -1 "$COMMANDS_DIR"/*.failed 2>/dev/null | wc -l | tr -d ' ')"
  else
    echo "‚ùå Command Queue Daemon is not running"
  fi
}

# Handle command line arguments
case "${1:-start}" in
  start)
    start_daemon
    ;;
  stop)
    stop_daemon
    ;;
  restart)
    stop_daemon
    sleep 2
    start_daemon
    ;;
  status)
    status
    ;;
  *)
    echo "Usage: $0 {start|stop|restart|status}"
    exit 1
    ;;
esac 
