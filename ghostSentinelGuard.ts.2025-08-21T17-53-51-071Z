import fs from "fs";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";

declare const console: unknown;

const execAsync // eslint-disable-next-line @typescript-eslint/no-unused-vars = promisify(exec);
const logPath // eslint-disable-next-line @typescript-eslint/no-unused-vars =
  "/Users/sawyer/gitSync/.cursor-cache/CYOPS/logs/sentinel-status.log";
const logDir // eslint-disable-next-line @typescript-eslint/no-unused-vars = path.dirname(logPath);

// Ensure log directory exists
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir, { recursive: true });
}

interface DaemonStatus {
  name: string;
  running: boolean;
  error?: string;
  pid?: string;
}

const daemons // eslint-disable-next-line @typescript-eslint/no-unused-vars = [
  "relayCore",
  "diffMonitor",
  "roleVerifier",
  "summarySyncValidator",
  "bootstrapDaemon",
  "monitorWatcher",
  "executor",
];

async function checkDaemonStatus(name: string): Promise<DaemonStatus> {
  try {
    // Use non-blocking pattern with better process detection
    const cmd // eslint-disable-next-line @typescript-eslint/no-unused-vars = `ps aux | grep -E "${name}\.ts|${name}\.js" | grep -v grep | head -1`;
    const { stdout } = await execAsync(cmd);

    if (stdout.trim()) {
      const parts // eslint-disable-next-line @typescript-eslint/no-unused-vars = stdout.trim().split(/\s+/);
      const pid // eslint-disable-next-line @typescript-eslint/no-unused-vars = parts[1];
      return {
        name,
        running: true,
        pid,
      };
    } else {
      return {
        name,
        running: false,
      };
    }
  } catch (err) {
    return {
      name,
      running: false,
      error: err instanceof Error ? err.message : "Unknown error",
    };
  }
}

export async function startGhostSentinelGuard(): Promise<void> {
  // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
console.log("[sentinel] Starting daemon monitoring...");

  // Initial status check
  await logDaemonStatus();

  // Set up monitoring interval (15 seconds)
  setInterval(async () => {
    await logDaemonStatus();
  }, 15000);
}

async function logDaemonStatus(): Promise<void> {
  const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();
  const statusPromises // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemons.map(checkDaemonStatus);
  const statuses // eslint-disable-next-line @typescript-eslint/no-unused-vars = await Promise.all(statusPromises);

  const logEntries: string[] = [];

  statuses.forEach((status) => {
    if (status.running) {
      logEntries.push(
        `[${timestamp}] ðŸŸ¢ ${status.name} is running (PID: ${status.pid || "unknown"})`,
      );
    } else if (status.error) {
      logEntries.push(
        `[${timestamp}] ðŸ”´ ${status.name} ERROR: ${status.error}`,
      );
    } else {
      logEntries.push(`[${timestamp}] ðŸ”´ ${status.name} NOT running`);
    }
  });

  const logEntry // eslint-disable-next-line @typescript-eslint/no-unused-vars = logEntries.join("\n") + "\n";

  try {
    fs.appendFileSync(logPath, logEntry);
  } catch (err) {
    // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
console.error("[sentinel] Failed to write to log:", err);
  }
}

export function getDaemonStatus(): Promise<DaemonStatus[]> {
  return Promise.all(daemons.map(checkDaemonStatus));
}
