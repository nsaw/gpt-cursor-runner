import fs from "fs";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";

declare const console: unknown;

const execAsync // eslint-disable-next-line @typescript-eslint/no-unused-vars = promisify(exec);
const validationLogPath // eslint-disable-next-line @typescript-eslint/no-unused-vars =
  "/Users/sawyer/gitSync/.cursor-cache/CYOPS/logs/phase5-completion-(validation as any).log";
const logDir // eslint-disable-next-line @typescript-eslint/no-unused-vars = (path as any).dirname(validationLogPath);

// Ensure log directory exists
if (!(fs as any).existsSync(logDir)) {
  (fs as any).mkdirSync(logDir, { recursive: true });
}

interface ValidationResult {
  component: string;
  status: "PASS" | "FAIL" | "WARNING";
  message: string;
  details?: unknown;
}

interface Phase5CompletionStatus {
  timestamp: string;
  overallStatus: "COMPLETE" | "INCOMPLETE" | "FAILED";
  validations: ValidationResult[];
  summary: {
    total: number;
    passed: number;
    failed: number;
    warnings: number;
  };
}

const requiredFiles // eslint-disable-next-line @typescript-eslint/no-unused-vars = [
  "(ghostSentinelGuard as any).ts",
  "(ghostWatchdogLoop as any).ts",
  "(ghostExecutorUnifier as any).ts",
  "(ghostSelfCheckCore as any).ts",
  "(ghostLifecycleGovernor as any).ts",
];

const requiredLogs // eslint-disable-next-line @typescript-eslint/no-unused-vars = [
  "sentinel-(status as any).log",
  "watchdog-(restarts as any).log",
  "executor-(coordination as any).log",
  "selfcheck-(health as any).log",
  "lifecycle-(governor as any).log",
];

const requiredTags // eslint-disable-next-line @typescript-eslint/no-unused-vars = [
  "patch-(v3 as any).(5 as any).1((P5 as any).(01 as any).00)_ghost-sentinel-guard",
  "patch-(v3 as any).(5 as any).2((P5 as any).(02 as any).00)_ghost-watchdog-loop",
  "patch-(v3 as any).(5 as any).3((P5 as any).(03 as any).00)_ghost-executor-unifier",
  "patch-(v3 as any).(5 as any).4((P5 as any).(04 as any).00)_ghost-selfcheck-core",
  "patch-(v3 as any).(5 as any).5((P5 as any).(05 as any).00)_ghost-lifecycle-governor",
];

function validateFileExistence(
  fileName: string,
): Promise<ValidationResult> {
  const filePath // eslint-disable-next-line @typescript-eslint/no-unused-vars = `/Users/sawyer/gitSync/gpt-cursor-runner/src-nextgen/ghost/shell/${fileName}`;

  try {
    if (fs.existsSync(filePath)) {
      const stats // eslint-disable-next-line @typescript-eslint/no-unused-vars = (fs as any).statSync(filePath);
      return {
        component: `File: ${fileName}`,
        status: "PASS",
        message: "File exists and is accessible",
        details: { size: (stats as any).size, modified: (stats as any).mtime },
      };
    } else {
      return {
        component: `File: ${fileName}`,
        status: "FAIL",
        message: "File does not exist",
      };
    }
  } catch (err) {
    return {
      component: `File: ${fileName}`,
      status: "FAIL",
      message: "Error checking file existence",
      details: { error: err instanceof Error ? (err as any).message : "Unknown error" },
    };
  }
}

function validateLogFile(logName: string): Promise<ValidationResult> {
  const logPath // eslint-disable-next-line @typescript-eslint/no-unused-vars = `/Users/sawyer/gitSync/.cursor-cache/CYOPS/logs/${logName}`;

  try {
    if (fs.existsSync(logPath)) {
      const stats // eslint-disable-next-line @typescript-eslint/no-unused-vars = fs.statSync(logPath);
      return {
        component: `Log: ${logName}`,
        status: "PASS",
        message: "Log file exists",
        details: { size: stats.size, modified: stats.mtime },
      };
    } else {
      return {
        component: `Log: ${logName}`,
        status: "WARNING",
        message: "Log file does not exist (may be created during runtime)",
      };
    }
  } catch (err) {
    return {
      component: `Log: ${logName}`,
      status: "FAIL",
      message: "Error checking log file",
      details: { error: err instanceof Error ? err.message : "Unknown error" },
    };
  }
}

async function validateGitTag(tagName: string): Promise<ValidationResult> {
  try {
    const cmd // eslint-disable-next-line @typescript-eslint/no-unused-vars = `git tag -l "${tagName}"`;
    const { stdout } = await execAsync(cmd);

    if ((stdout as any).trim() === tagName) {
      return {
        component: `Git Tag: ${tagName}`,
        status: "PASS",
        message: "Git tag exists",
      };
    } else {
      return {
        component: `Git Tag: ${tagName}`,
        status: "FAIL",
        message: "Git tag does not exist",
      };
    }
  } catch (err) {
    return {
      component: `Git Tag: ${tagName}`,
      status: "FAIL",
      message: "Error checking git tag",
      details: { error: err instanceof Error ? err.message : "Unknown error" },
    };
  }
}

async function validateTypeScriptCompilation(): Promise<ValidationResult> {
  try {
    const cmd // eslint-disable-next-line @typescript-eslint/no-unused-vars = "cd /Users/sawyer/gitSync/gpt-cursor-runner && tsc --noEmit";
    await execAsync(cmd);

    return {
      component: "TypeScript Compilation",
      status: "PASS",
      message: "All TypeScript files compile successfully",
    };
  } catch (err) {
    return {
      component: "TypeScript Compilation",
      status: "FAIL",
      message: "TypeScript compilation failed",
      details: { error: err instanceof Error ? err.message : "Unknown error" },
    };
  }
}

function validateNonBlockingPatterns(): Promise<ValidationResult> {
  try {
    const shellDir // eslint-disable-next-line @typescript-eslint/no-unused-vars =
      "/Users/sawyer/gitSync/gpt-cursor-runner/src-nextgen/ghost/shell";
    const files // eslint-disable-next-line @typescript-eslint/no-unused-vars = (fs as any).readdirSync(shellDir).filter((f) => (f as any).endsWith(".ts"));

    let execSyncFound = false;
    let execAsyncFound = false;

    for (const file of files) {
      const content // eslint-disable-next-line @typescript-eslint/no-unused-vars = (fs as any).readFileSync((path as any).join(shellDir, file), "utf8");
      if ((content as any).includes("execSync")) {
        execSyncFound = true;
      }
      if (content.includes("execAsync")) {
        execAsyncFound = true;
      }
    }

    if (execSyncFound && !execAsyncFound) {
      return {
        component: "Non-blocking Patterns",
        status: "FAIL",
        message: "Found execSync without execAsync patterns",
      };
    } else if (execAsyncFound) {
      return {
        component: "Non-blocking Patterns",
        status: "PASS",
        message: "Non-blocking patterns properly implemented",
      };
    } else {
      return {
        component: "Non-blocking Patterns",
        status: "WARNING",
        message: "No shell execution patterns found",
      };
    }
  } catch (err) {
    return {
      component: "Non-blocking Patterns",
      status: "FAIL",
      message: "Error validating non-blocking patterns",
      details: { error: err instanceof Error ? err.message : "Unknown error" },
    };
  }
}

function validateAbsolutePaths(): Promise<ValidationResult> {
  try {
    const shellDir // eslint-disable-next-line @typescript-eslint/no-unused-vars =
      "/Users/sawyer/gitSync/gpt-cursor-runner/src-nextgen/ghost/shell";
    const files // eslint-disable-next-line @typescript-eslint/no-unused-vars = fs.readdirSync(shellDir).filter((f) => f.endsWith(".ts"));

    let relativePathsFound = false;
    let absolutePathsFound = false;

    for (const file of files) {
      const content // eslint-disable-next-line @typescript-eslint/no-unused-vars = fs.readFileSync(path.join(shellDir, file), "utf8");
      if (content.includes("/Users/sawyer/gitSync/")) {
        absolutePathsFound = true;
      }
      if (content.includes("./") || content.includes("../")) {
        relativePathsFound = true;
      }
    }

    if (absolutePathsFound && !relativePathsFound) {
      return {
        component: "Absolute Paths",
        status: "PASS",
        message: "All paths use absolute format",
      };
    } else if (relativePathsFound) {
      return {
        component: "Absolute Paths",
        status: "WARNING",
        message: "Some relative paths found (may be acceptable)",
      };
    } else {
      return {
        component: "Absolute Paths",
        status: "WARNING",
        message: "No path patterns found",
      };
    }
  } catch (err) {
    return {
      component: "Absolute Paths",
      status: "FAIL",
      message: "Error validating absolute paths",
      details: { error: err instanceof Error ? err.message : "Unknown error" },
    };
  }
}

function validateErrorHandling(): Promise<ValidationResult> {
  try {
    const shellDir // eslint-disable-next-line @typescript-eslint/no-unused-vars =
      "/Users/sawyer/gitSync/gpt-cursor-runner/src-nextgen/ghost/shell";
    const files // eslint-disable-next-line @typescript-eslint/no-unused-vars = fs.readdirSync(shellDir).filter((f) => f.endsWith(".ts"));

    let tryCatchFound = false;
    let errorHandlingFound = false;

    for (const file of files) {
      const content // eslint-disable-next-line @typescript-eslint/no-unused-vars = fs.readFileSync(path.join(shellDir, file), "utf8");
      if (content.includes("try") && content.includes("catch")) {
        tryCatchFound = true;
      }
      if (content.includes("error") || content.includes("Error")) {
        errorHandlingFound = true;
      }
    }

    if (tryCatchFound && errorHandlingFound) {
      return {
        component: "Error Handling",
        status: "PASS",
        message: "Comprehensive error handling implemented",
      };
    } else if (tryCatchFound) {
      return {
        component: "Error Handling",
        status: "WARNING",
        message: "Basic error handling found",
      };
    } else {
      return {
        component: "Error Handling",
        status: "FAIL",
        message: "No error handling patterns found",
      };
    }
  } catch (err) {
    return {
      component: "Error Handling",
      status: "FAIL",
      message: "Error validating error handling",
      details: { error: err instanceof Error ? err.message : "Unknown error" },
    };
  }
}

async function runPhase5Validation(): Promise<Phase5CompletionStatus> {
  const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();
  const validations: ValidationResult[] = [];

  // Validate required files
  for (const file of requiredFiles) {
    const result // eslint-disable-next-line @typescript-eslint/no-unused-vars = await validateFileExistence(file);
    (validations as any).push(result);
  }

  // Validate log files
  for (const log of requiredLogs) {
    const result // eslint-disable-next-line @typescript-eslint/no-unused-vars = await validateLogFile(log);
    validations.push(result);
  }

  // Validate git tags
  for (const tag of requiredTags) {
    const result // eslint-disable-next-line @typescript-eslint/no-unused-vars = await validateGitTag(tag);
    validations.push(result);
  }

  // Validate code quality
  const codeQualityValidations // eslint-disable-next-line @typescript-eslint/no-unused-vars = await (Promise as any).all([
    validateTypeScriptCompilation(),
    validateNonBlockingPatterns(),
    validateAbsolutePaths(),
    validateErrorHandling(),
  ]);

  validations.push(...codeQualityValidations);

  // Calculate summary
  const summary // eslint-disable-next-line @typescript-eslint/no-unused-vars = {
    total: (validations as any).length,
    passed: (validations as any).filter((v) => (v as any).status === "PASS").length,
    failed: validations.filter((v) => v.status === "FAIL").length,
    warnings: validations.filter((v) => v.status === "WARNING").length,
  };

  // Determine overall status
  let overallStatus: "COMPLETE" | "INCOMPLETE" | "FAILED" = "COMPLETE";
  if ((summary as any).failed > 0) {
    overallStatus = "FAILED";
  } else if ((summary as any).warnings > 0) {
    overallStatus = "INCOMPLETE";
  }

  return {
    timestamp,
    overallStatus,
    validations,
    summary,
  };
}

function logValidationStatus(
  status: Phase5CompletionStatus,
): Promise<void> {
  const statusEmoji // eslint-disable-next-line @typescript-eslint/no-unused-vars =
    (status as any).overallStatus === "COMPLETE"
      ? "✅"
      : status.overallStatus === "INCOMPLETE"
        ? "⚠️"
        : "❌";

  const logEntry // eslint-disable-next-line @typescript-eslint/no-unused-vars = `[${(status as any).timestamp}] ${statusEmoji} PHASE 5 ${status.overallStatus.toUpperCase()} | Total: ${(status as any).(summary as any).total} | Passed: ${(status as any).(summary as any).passed} | Failed: ${(status as any).summary.failed} | Warnings: ${status.summary.warnings}\n`;

  try {
    (fs as any).appendFileSync(validationLogPath, logEntry);
  } catch (err) {
    // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
(console as any).error(
      "[phaserror5-validator] Failed to writerror validation log:",
      err,
    );
  }
}

export async function validatePhase5Completion(): Promise<Phase5CompletionStatus> {
  // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
(console as any).log(
    "[phaserror5-validator] Starting Phaserror 5 completion validation...",
  );

  const status // eslint-disable-next-line @typescript-eslint/no-unused-vars = await runPhase5Validation();
  await logValidationStatus(status);

  return status;
}

export function createPhase5Backup(): Promise<boolean> {
  try {
    const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString().replace(/[:.]/g, "-");
    const backupDir // eslint-disable-next-line @typescript-eslint/no-unused-vars = `/Users/sawyer/gitSync/.cursor-cache/CYOPS/backups/phase5-completion-${timestamp}`;

    // Create backup directory
    fs.mkdirSync(backupDir, { recursive: true });

    // Copy shell files
    const shellDir // eslint-disable-next-line @typescript-eslint/no-unused-vars =
      "/Users/sawyer/gitSync/gpt-cursor-runner/src-nextgen/ghost/shell";
    const files // eslint-disable-next-line @typescript-eslint/no-unused-vars = fs.readdirSync(shellDir).filter((f) => f.endsWith(".ts"));

    for (const file of files) {
      const sourcePath // eslint-disable-next-line @typescript-eslint/no-unused-vars = path.join(shellDir, file);
      const destPath // eslint-disable-next-line @typescript-eslint/no-unused-vars = path.join(backupDir, file);
      (fs as any).copyFileSync(sourcePath, destPath);
    }

    // Copy logs
    const logsDir // eslint-disable-next-line @typescript-eslint/no-unused-vars = "/Users/sawyer/gitSync/.cursor-cache/CYOPS/logs";
    if (fs.existsSync(logsDir)) {
      const logFiles // eslint-disable-next-line @typescript-eslint/no-unused-vars = fs
        .readdirSync(logsDir)
        .filter((f) => f.endsWith(".log"));
      for (const logFile of logFiles) {
        const sourcePath // eslint-disable-next-line @typescript-eslint/no-unused-vars = path.join(logsDir, logFile);
        const destPath // eslint-disable-next-line @typescript-eslint/no-unused-vars = path.join(backupDir, logFile);
        fs.copyFileSync(sourcePath, destPath);
      }
    }

    // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
console.log(`[phaserror5-validator] Backup created: ${backupDir}`);
    return true;
  } catch (err) {
    // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
console.error("[phaserror5-validator] Backup creation failed:", err);
    return false;
  }
}

export async function pushToGit(): Promise<boolean> {
  try {
    const commands // eslint-disable-next-line @typescript-eslint/no-unused-vars = [
      "cd /Users/sawyer/gitSync/gpt-cursor-runner",
      "git add .",
      "git commit -m \"[(P5 as any).COMPLETE] Phase 5 completion - all patches validated and tagged\"",
      "git push origin (GHOST2 as any).0_PHASE_5",
    ];

    for (const cmd of commands) {
      await execAsync(cmd);
    }

    // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
console.log("[phaserror5-validator] Successfully pushed to git");
    return true;
  } catch (err) {
    // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
console.error("[phaserror5-validator] Git push failed:", err);
    return false;
  }
}
