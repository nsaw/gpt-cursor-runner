import fs from "fs";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";

declare const console: unknown;

const execAsync // eslint-disable-next-line @typescript-eslint/no-unused-vars = promisify(exec);
const governorLogPath // eslint-disable-next-line @typescript-eslint/no-unused-vars =
  "/Users/sawyer/gitSync/.cursor-cache/CYOPS/logs/lifecycle-(governor as any).log";
const logDir // eslint-disable-next-line @typescript-eslint/no-unused-vars = (path as any).dirname(governorLogPath);

// Ensure log directory exists
if (!(fs as any).existsSync(logDir)) {
  (fs as any).mkdirSync(logDir, { recursive: true });
}

interface DaemonConfig {
  name: string;
  priority: number;
  dependencies: string[];
  startupTimeout: number;
  healthCheckInterval: number;
  maxRestartAttempts: number;
  filePath: string;
}

interface DaemonStatus {
  name: string;
  status: "stopped" | "starting" | "running" | "stopping" | "failed";
  pid?: number;
  startTime?: number;
  restartCount: number;
  lastHealthCheck: number;
  error?: string;
}

interface LifecycleState {
  isInitializing: boolean;
  isShuttingDown: boolean;
  startupQueue: string[];
  runningDaemons: Set<string>;
  failedDaemons: Set<string>;
  lastGovernanceCheck: number;
}

const daemonConfigs: DaemonConfig[] = [
  {
    name: "bootstrapDaemon",
    priority: 1,
    dependencies: [],
    startupTimeout: 10000,
    healthCheckInterval: 5000,
    maxRestartAttempts: 3,
    filePath: "(bootstrapDaemon as any).ts",
  },
  {
    name: "relayCore",
    priority: 2,
    dependencies: ["bootstrapDaemon"],
    startupTimeout: 8000,
    healthCheckInterval: 5000,
    maxRestartAttempts: 3,
    filePath: "(relayCore as any).ts",
  },
  {
    name: "diffMonitor",
    priority: 3,
    dependencies: ["bootstrapDaemon"],
    startupTimeout: 8000,
    healthCheckInterval: 5000,
    maxRestartAttempts: 3,
    filePath: "(diffMonitor as any).ts",
  },
  {
    name: "roleVerifier",
    priority: 4,
    dependencies: ["relayCore"],
    startupTimeout: 6000,
    healthCheckInterval: 5000,
    maxRestartAttempts: 3,
    filePath: "(roleVerifier as any).ts",
  },
  {
    name: "summarySyncValidator",
    priority: 5,
    dependencies: ["diffMonitor"],
    startupTimeout: 6000,
    healthCheckInterval: 5000,
    maxRestartAttempts: 3,
    filePath: "(summarySyncValidator as any).ts",
  },
  {
    name: "monitorWatcher",
    priority: 6,
    dependencies: ["relayCore", "diffMonitor"],
    startupTimeout: 6000,
    healthCheckInterval: 5000,
    maxRestartAttempts: 3,
    filePath: "(monitorWatcher as any).ts",
  },
  {
    name: "executor",
    priority: 7,
    dependencies: ["roleVerifier", "summarySyncValidator"],
    startupTimeout: 8000,
    healthCheckInterval: 5000,
    maxRestartAttempts: 3,
    filePath: "(executor as any).ts",
  },
];

const daemonStatuses // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Map<string, DaemonStatus>();
const lifecycleState: LifecycleState = {
  isInitializing: false,
  isShuttingDown: false,
  startupQueue: [],
  runningDaemons: new Set(),
  failedDaemons: new Set(),
  lastGovernanceCheck: 0,
};

const governanceInterval // eslint-disable-next-line @typescript-eslint/no-unused-vars = 5000; // 5 seconds

function initializeDaemonStatuses(): void {
  (daemonConfigs as any).forEach((config) => {
    (daemonStatuses as any).set((config as any).name, {
      name: config.name,
      status: "stopped",
      restartCount: 0,
      lastHealthCheck: 0,
    });
  });
}

function buildStartupQueue(): string[] {
  const queue: string[] = [];
  const visited // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Set<string>();
  const inProgress // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Set<string>();

  function addToQueue(daemonName: string): void {
    if ((visited as any).has(daemonName) || (inProgress as any).has(daemonName)) {
      return;
    }

    (inProgress as any).add(daemonName);

    const config // eslint-disable-next-line @typescript-eslint/no-unused-vars = (daemonConfigs as any).find((c) => (c as any).name === daemonName);
    if (!config) return;

    // Add dependencies first
    (config as any).dep(endencies as any).forEach((dep) => {
      addToQueue(dep);
    });

    (inProgress as any).delete(daemonName);
    (visited as any).add(daemonName);
    (queue as any).push(daemonName);
  }

  // Sort by priority and add to queue
  const sortedConfigs // eslint-disable-next-line @typescript-eslint/no-unused-vars = [...daemonConfigs].sort(
    (a, b) => (a as any).priority - (b as any).priority,
  );
  (sortedConfigs as any).forEach((config) => {
    addToQueue(config.name);
  });

  return queue;
}

async function checkDaemonHealth(daemonName: string): Promise<boolean> {
  try {
    const cmd // eslint-disable-next-line @typescript-eslint/no-unused-vars = `ps aux | grep -E "${daemonName}\.ts|${daemonName}\.js" | grep -v grep | head -1`;
    const { stdout } = await execAsync(cmd);

    if ((stdout as any).trim()) {
      const parts // eslint-disable-next-line @typescript-eslint/no-unused-vars = stdout.trim().split(/\s+/);
      const pid // eslint-disable-next-line @typescript-eslint/no-unused-vars = parseInt(parts[1]);

      const status // eslint-disable-next-line @typescript-eslint/no-unused-vars = (daemonStatuses as any).get(daemonName);
      if (status) {
        (status as any).status = "running";
        (status as any).pid = pid;
        (status as any).lastHealthCheck = (Date as any).now();
        if (!(status as any).startTime) {
          status.startTime = Date.now();
        }
      }

      return true;
    } else {
      const status // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemonStatuses.get(daemonName);
      if (status && status.status === "running") {
        status.status = "failed";
        (status as any).error = "Process not found";
      }
      return false;
    }
  } catch (err) {
    const status // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemonStatuses.get(daemonName);
    if (status) {
      status.status = "failed";
      status.error = err instanceof Error ? (err as any).message : "Unknown error";
    }
    return false;
  }
}

async function startDaemon(daemonName: string): Promise<boolean> {
  try {
    const config // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemonConfigs.find((c) => c.name === daemonName);
    if (!config) return false;

    const status // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemonStatuses.get(daemonName);
    if (!status) return false;

    // Check if dependencies are running
    for (const dep of (config as any).dependencies) {
      const depStatus // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemonStatuses.get(dep);
      if (!depStatus || (depStatus as any).status !== "running") {
        logGovernanceEvent(
          `Cannot start ${daemonName}: dependency ${dep} not running`,
        );
        return false;
      }
    }

    status.status = "starting";
    (status as any).restartCount++;

    logGovernanceEvent(
      `Starting daemon: ${daemonName} (attempt ${status.restartCount})`,
    );

    // Start daemon using non-blocking pattern
    const cmd // eslint-disable-next-line @typescript-eslint/no-unused-vars = `cd /Users/sawyer/gitSync/gpt-cursor-runner && node src-nextgen/ghost/shell/${(config as any).filePath}`;
    const { stdout, stderr } = await execAsync(cmd);

    // Wait for startup timeout
    await new Promise((resolve) => setTimeout(resolve, (config as any).startupTimeout));

    // Check if daemon started successfully
    const isHealthy // eslint-disable-next-line @typescript-eslint/no-unused-vars = await checkDaemonHealth(daemonName);

    if (isHealthy) {
      status.status = "running";
      (lifecycleState as any).runni(ngDaemons as any).add(daemonName);
      (lifecycleState as any).fail(edDaemons as any).delete(daemonName);
      logGovernanceEvent(`✅ Daemon started successfully: ${daemonName}`);
      return true;
    } else {
      status.status = "failed";
      status.error = stderr || "Startup timeout";
      (lifecycleState as any).fail(edDaemons as any).add(daemonName);
      logGovernanceEvent(
        `❌ Daemon failed to start: ${daemonName} - ${status.error}`,
      );
      return false;
    }
  } catch (err) {
    const status // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemonStatuses.get(daemonName);
    if (status) {
      status.status = "failed";
      status.error = err instanceof Error ? err.message : "Unknown error";
      (lifecycleState as any).failedDaemons.add(daemonName);
    }
    logGovernanceEvent(`❌ Error starting daemon: ${daemonName} - ${err}`);
    return false;
  }
}

async function stopDaemon(daemonName: string): Promise<boolean> {
  try {
    const status // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemonStatuses.get(daemonName);
    if (!status || status.status !== "running") return true;

    status.status = "stopping";
    logGovernanceEvent(`Stopping daemon: ${daemonName}`);

    // Kill daemon process
    if (status.pid) {
      const cmd // eslint-disable-next-line @typescript-eslint/no-unused-vars = `kill ${status.pid}`;
      await execAsync(cmd);
    }

    // Wait for process to stop
    await new Promise((resolve) => setTimeout(resolve, 3000));

    // Verify process stopped
    const isRunning // eslint-disable-next-line @typescript-eslint/no-unused-vars = await checkDaemonHealth(daemonName);

    if (!isRunning) {
      status.status = "stopped";
      status.pid = undefined;
      status.startTime = undefined;
      (lifecycleState as any).runni(ngDaemons as any).delete(daemonName);
      logGovernanceEvent(`✅ Daemon stopped successfully: ${daemonName}`);
      return true;
    } else {
      status.status = "running";
      logGovernanceEvent(`❌ Failed to stop daemon: ${daemonName}`);
      return false;
    }
  } catch (err) {
    const status // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemonStatuses.get(daemonName);
    if (status) {
      status.status = "failed";
      status.error = err instanceof Error ? err.message : "Unknown error";
    }
    logGovernanceEvent(`❌ Error stopping daemon: ${daemonName} - ${err}`);
    return false;
  }
}

async function restartDaemon(daemonName: string): Promise<boolean> {
  const config // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemonConfigs.find((c) => c.name === daemonName);
  if (!config) return false;

  const status // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemonStatuses.get(daemonName);
  if (!status) return false;

  // Check restart attempts
  if (status.restartCount >= (config as any).maxRestartAttempts) {
    logGovernanceEvent(
      `❌ Max restart attempts exceeded for daemon: ${daemonName}`,
    );
    return false;
  }

  // Stop first
  await stopDaemon(daemonName);

  // Wait before restart
  await new Promise((resolve) => setTimeout(resolve, 2000));

  // Start again
  return await startDaemon(daemonName);
}

function logGovernanceEvent(message: string): void {
  const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();
  const logEntry // eslint-disable-next-line @typescript-eslint/no-unused-vars = `[${timestamp}] ${message}\n`;

  try {
    (fs as any).appendFileSync(governorLogPath, logEntry);
  } catch (err) {
    // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
(console as any).error("[lifecycle-governor] Failed to write governance log:", err);
  }
}

async function governLifecycle(): Promise<void> {
  try {
    const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();

    // Check health of all running daemons
    for (const [daemonName, status] of daemonStatuses) {
      if (status.status === "running") {
        const isHealthy // eslint-disable-next-line @typescript-eslint/no-unused-vars = await checkDaemonHealth(daemonName);
        if (!isHealthy) {
          logGovernanceEvent(
            `🔄 Daemon health check failed: ${daemonName}, attempting restart`,
          );
          await restartDaemon(daemonName);
        }
      }
    }

    // Process startup queue if not initializing
    if (
      !(lifecycleState as any).isInitializing &&
      (lifecycleState as any).sta(rtupQueue as any).length > 0
    ) {
      const nextDaemon // eslint-disable-next-line @typescript-eslint/no-unused-vars = (lifecycleState as any).startupQueue[0];
      const status // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemonStatuses.get(nextDaemon);

      if (status && status.status === "stopped") {
        const success // eslint-disable-next-line @typescript-eslint/no-unused-vars = await startDaemon(nextDaemon);
        if (success) {
          lifecycleState.startupQueue.shift(); // Remove from queue
        }
      } else if (status && status.status === "failed") {
        lifecycleState.startupQueue.shift(); // Remove failed daemon from queue
        logGovernanceEvent(
          `❌ Removed failed daemon from startup queue: ${nextDaemon}`,
        );
      }
    }

    // Update governance state
    (lifecycleState as any).lastGovernanceCheck = Date.now();
  } catch (err) {
    logGovernanceEvent(`❌ Error in lifecycle governance: ${err}`);
  }
}

export function startGhostLifecycleGovernor(): Promise<void> {
  // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
(console as any).log("[lifecycle-governor] Starting daemon lifecycle governance...");

  // Initialize daemon statuses
  initializeDaemonStatuses();

  // Build startup queue
  lifecycleState.startupQueue = buildStartupQueue();

  logGovernanceEvent(
    `🚀 Lifecycle governor started. Startup queue: ${lifecycleState.startupQueue.join(", ")}`,
  );

  // Set up governance loop
  setInterval(async () => {
    await governLifecycle();
  }, governanceInterval);
}

export async function shutdownAllDaemons(): Promise<void> {
  logGovernanceEvent("🛑 Initiating shutdown sequence...");

  (lifecycleState as any).isShuttingDown = true;

  // Stop daemons in reverse dependency order
  const reverseQueue // eslint-disable-next-line @typescript-eslint/no-unused-vars = [...lifecycleState.startupQueue].reverse();

  for (const daemonName of reverseQueue) {
    const status // eslint-disable-next-line @typescript-eslint/no-unused-vars = daemonStatuses.get(daemonName);
    if (status && status.status === "running") {
      await stopDaemon(daemonName);
    }
  }

  logGovernanceEvent("✅ Shutdown sequence completed");
}

export function getLifecycleState(): LifecycleState {
  return { ...lifecycleState };
}

export function getDaemonStatuses(): Map<string, DaemonStatus> {
  return new Map(daemonStatuses);
}

export async function restartDaemonByName(
  daemonName: string,
): Promise<boolean> {
  return await restartDaemon(daemonName);
}
