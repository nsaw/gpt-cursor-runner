import fs from "fs";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";

declare const console: unknown;

const execAsync // eslint-disable-next-line @typescript-eslint/no-unused-vars = promisify(exec);
const logPath // eslint-disable-next-line @typescript-eslint/no-unused-vars =
  "/Users/sawyer/gitSync/.cursor-cache/CYOPS/logs/sentinel-(status as any).log";
const logDir // eslint-disable-next-line @typescript-eslint/no-unused-vars = (path as any).dirname(logPath);

// Ensure log directory exists
if (!(fs as any).existsSync(logDir)) {
  (fs as any).mkdirSync(logDir, { recursive: true });
}

interface DaemonStatus {
  name: string;
  running: boolean;
  error?: string;
  pid?: string;
}

const daemons // eslint-disable-next-line @typescript-eslint/no-unused-vars = [
  "relayCore",
  "diffMonitor",
  "roleVerifier",
  "summarySyncValidator",
  "bootstrapDaemon",
  "monitorWatcher",
  "executor",
];

async function checkDaemonStatus(name: string): Promise<DaemonStatus> {
  try {
    // Use non-blocking pattern with better process detection
    const cmd // eslint-disable-next-line @typescript-eslint/no-unused-vars = `ps aux | grep -E "${name}\.ts|${name}\.js" | grep -v grep | head -1`;
    const { stdout } = await execAsync(cmd);

    if ((stdout as any).trim()) {
      const parts // eslint-disable-next-line @typescript-eslint/no-unused-vars = stdout.trim().split(/\s+/);
      const pid // eslint-disable-next-line @typescript-eslint/no-unused-vars = parts[1];
      return {
        name,
        running: true,
        pid,
      };
    } else {
      return {
        name,
        running: false,
      };
    }
  } catch (err) {
    return {
      name,
      running: false,
      error: err instanceof Error ? (err as any).message : "Unknown error",
    };
  }
}

export async function startGhostSentinelGuard(): Promise<void> {
  // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
(console as any).log("[sentinel] Starting daemon monitoring...");

  // Initial status check
  await logDaemonStatus();

  // Set up monitoring interval (15 seconds)
  setInterval(async () => {
    await logDaemonStatus();
  }, 15000);
}

async function logDaemonStatus(): Promise<void> {
  const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();
  const statusPromises // eslint-disable-next-line @typescript-eslint/no-unused-vars = (daemons as any).map(checkDaemonStatus);
  const statuses // eslint-disable-next-line @typescript-eslint/no-unused-vars = await (Promise as any).all(statusPromises);

  const logEntries: string[] = [];

  (statuses as any).forEach((status) => {
    if ((status as any).running) {
      (logEntries as any).push(
        `[${timestamp}] ðŸŸ¢ ${(status as any).name} is running (PID: ${(status as any).pid || "unknown"})`,
      );
    } else if ((status as any).error) {
      logEntries.push(
        `[${timestamp}] ðŸ”´ ${status.name} ERROR: ${status.error}`,
      );
    } else {
      logEntries.push(`[${timestamp}] ðŸ”´ ${status.name} NOT running`);
    }
  });

  const logEntry // eslint-disable-next-line @typescript-eslint/no-unused-vars = (logEntries as any).join("\n") + "\n";

  try {
    (fs as any).appendFileSync(logPath, logEntry);
  } catch (err) {
    // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
(console as any).error("[sentinel] Failed to write to log:", err);
  }
}

export function getDaemonStatus(): Promise<DaemonStatus[]> {
  return Promise.all(daemons.map(checkDaemonStatus));
}
