const express = require('express');
const router = express.Router();
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// Fallback webhook endpoint
router.post('/trigger', async (req, res) => {
  const { patch_id, target_file, patch_content, description, source } = req.body;
  
  console.log('🚨 Fallback trigger received:', {
    patch_id,
    target_file,
    source,
    timestamp: new Date().toISOString()
  });
  
  try {
    // Validate required fields
    if (!patch_id || !target_file) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: patch_id, target_file'
      });
    }
    
    // Generate unique operation ID
    const operationId = crypto.randomUUID();
    const timestamp = new Date().toISOString();
    
    // Log the fallback attempt
    const logEntry = {
      operation_id: operationId,
      timestamp,
      patch_id,
      target_file,
      description: description || 'No description provided',
      source: source || 'unknown',
      status: 'triggered'
    };
    
    // Append to fallback bridge log
    const logFile = path.join(__dirname, '../../logs/fallback-bridge.log');
    fs.appendFileSync(logFile, JSON.stringify(logEntry) + '\n');
    
    // Get GitHub PAT from environment or 1Password
    const githubPat = process.env.GITHUB_PAT || process.env.GITHUB_TOKEN;
    if (!githubPat) {
      console.error('❌ No GitHub PAT available for fallback trigger');
      return res.status(500).json({
        success: false,
        error: 'GitHub PAT not configured'
      });
    }
    
    // Prepare GitHub API payload
    const githubPayload = {
      event_type: 'fallback-patch',
      client_payload: {
        patch_id,
        target_file,
        patch_content: patch_content || JSON.stringify({
          pattern: '## Fallback Patch',
          replacement: '## Fallback Patch\n\n✅ Applied via GitHub Actions fallback bridge'
        }),
        description: description || 'Fallback patch triggered via webhook',
        source: source || 'webhook',
        operation_id: operationId,
        timestamp
      }
    };
    
    // Trigger GitHub Actions workflow
    const response = await fetch(`https://api.github.com/repos/${process.env.GITHUB_REPOSITORY || 'nsaw/gpt-cursor-runner'}/dispatches`, {
      method: 'POST',
      headers: {
        'Authorization': `token ${githubPat}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(githubPayload)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('❌ GitHub API error:', response.status, errorText);
      
      // Log the failure
      const failureLog = {
        ...logEntry,
        status: 'failed',
        error: `GitHub API error: ${response.status} - ${errorText}`
      };
      fs.appendFileSync(logFile, JSON.stringify(failureLog) + '\n');
      
      return res.status(500).json({
        success: false,
        error: `GitHub API error: ${response.status}`,
        details: errorText
      });
    }
    
    // Log success
    const successLog = {
      ...logEntry,
      status: 'success',
      github_response: response.status
    };
    fs.appendFileSync(logFile, JSON.stringify(successLog) + '\n');
    
    // Create summary markdown
    const summaryContent = `# Fallback Bridge Trigger Summary - ${new Date().toISOString()}

## 🚨 Fallback Triggered

**Operation ID:** ${operationId}
**Patch ID:** ${patch_id}
**Target File:** ${target_file}
**Source:** ${source || 'webhook'}
**Timestamp:** ${timestamp}

## 📋 Trigger Details

- **Description:** ${description || 'No description provided'}
- **GitHub Response:** ${response.status}
- **Status:** Successfully triggered GitHub Actions workflow

## ✅ Next Steps

1. Monitor GitHub Actions workflow execution
2. Verify patch application in repository
3. Check for any errors in workflow logs
4. Resume normal GHOST operations when available

---
*Generated by fallback bridge webhook*`;

    const summaryFile = path.join(__dirname, '../../summaries/fallback-bridge-trigger-' + new Date().toISOString().replace(/[:.]/g, '-') + '.md');
    fs.writeFileSync(summaryFile, summaryContent);
    
    console.log('✅ Fallback trigger successful:', operationId);
    
    res.json({
      success: true,
      operation_id: operationId,
      message: 'Fallback trigger sent to GitHub Actions',
      summary_file: path.basename(summaryFile)
    });
    
  } catch (error) {
    console.error('❌ Fallback trigger error:', error);
    
    // Log the error
    const errorLog = {
      operation_id: crypto.randomUUID(),
      timestamp: new Date().toISOString(),
      patch_id,
      target_file,
      status: 'error',
      error: error.message
    };
    
    const logFile = path.join(__dirname, '../../logs/fallback-bridge.log');
    fs.appendFileSync(logFile, JSON.stringify(errorLog) + '\n');
    
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get fallback bridge status
router.get('/status', (req, res) => {
  try {
    const logFile = path.join(__dirname, '../../logs/fallback-bridge.log');
    let recentLogs = [];
    
    if (fs.existsSync(logFile)) {
      const logLines = fs.readFileSync(logFile, 'utf8').trim().split('\n').slice(-10);
      recentLogs = logLines.map(line => {
        try {
          return JSON.parse(line);
        } catch {
          return null;
        }
      }).filter(Boolean);
    }
    
    const status = {
      bridge_active: true,
      github_pat_configured: !!(process.env.GITHUB_PAT || process.env.GITHUB_TOKEN),
      recent_triggers: recentLogs.length,
      last_trigger: recentLogs[recentLogs.length - 1] || null,
      timestamp: new Date().toISOString()
    };
    
    res.json(status);
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

module.exports = router; 