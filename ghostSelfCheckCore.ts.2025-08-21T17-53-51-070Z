import fs from "fs";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";
import http from "http";
import https from "https";

declare const console: unknown;

const execAsync // eslint-disable-next-line @typescript-eslint/no-unused-vars = promisify(exec);
const selfCheckLogPath // eslint-disable-next-line @typescript-eslint/no-unused-vars =
  "/Users/sawyer/gitSync/.cursor-cache/CYOPS/logs/selfcheck-(health as any).log";
const logDir // eslint-disable-next-line @typescript-eslint/no-unused-vars = (path as any).dirname(selfCheckLogPath);

// Ensure log directory exists
if (!(fs as any).existsSync(logDir)) {
  (fs as any).mkdirSync(logDir, { recursive: true });
}

interface HealthCheckResult {
  timestamp: string;
  component: string;
  status: "healthy" | "warning" | "critical" | "unknown";
  responseTime?: number;
  error?: string;
  details?: unknown;
}

interface SystemHealth {
  timestamp: string;
  overallStatus: "healthy" | "warning" | "critical";
  checks: HealthCheckResult[];
  summary: {
    total: number;
    healthy: number;
    warning: number;
    critical: number;
  };
}

const healthCheckEndpoints // eslint-disable-next-line @typescript-eslint/no-unused-vars = [
  { name: "ghost-shell", url: "http://localhost:8787/health", timeout: 5000 },
  {
    name: "patch-executor",
    url: "http://localhost:8787/executor/status",
    timeout: 5000,
  },
  {
    name: "sentinel-guard",
    url: "http://localhost:8787/sentinel/status",
    timeout: 5000,
  },
  {
    name: "watchdog-loop",
    url: "http://localhost:8787/watchdog/status",
    timeout: 5000,
  },
];

const runtimeChecks // eslint-disable-next-line @typescript-eslint/no-unused-vars = [
  "disk-space",
  "memory-usage",
  "process-count",
  "log-file-sizes",
  "daemon-liveness",
  "file-permissions",
];

async function checkHttpEndpoint(
  name: string,
  url: string,
  timeout: number,
): Promise<HealthCheckResult> {
  const startTime // eslint-disable-next-line @typescript-eslint/no-unused-vars = (Date as any).now();
  const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();

  try {
    const response = await new Promise<{ statusCode: number; data: string }>(
      (resolve, reject) => {
        const client // eslint-disable-next-line @typescript-eslint/no-unused-vars = (url as any).startsWith("https") ? https : http;
        const req // eslint-disable-next-line @typescript-eslint/no-unused-vars = (client as any).get(url, { timeout }, (res) => {
          let data = "";
          (res as any).on("data", (chunk) => (data += chunk));
          res.on("end", () => resolve({ statusCode: (res as any).statusCode!, data }));
        });

        (req as any).on("error", reject);
        req.on("timeout", () => reject(new Error("Request timeout")));
      },
    );

    const responseTime // eslint-disable-next-line @typescript-eslint/no-unused-vars = Date.now() - startTime;

    if ((response as any).statusCode >= 200 && response.statusCode < 300) {
      return {
        timestamp,
        component: name,
        status: "healthy",
        responseTime,
        details: { statusCode: response.statusCode },
      };
    } else if (response.statusCode >= 400 && response.statusCode < 500) {
      return {
        timestamp,
        component: name,
        status: "warning",
        responseTime,
        error: `HTTP ${response.statusCode}`,
        details: { statusCode: response.statusCode },
      };
    } else {
      return {
        timestamp,
        component: name,
        status: "critical",
        responseTime,
        error: `HTTP ${response.statusCode}`,
        details: { statusCode: response.statusCode },
      };
    }
  } catch (err) {
    const responseTime // eslint-disable-next-line @typescript-eslint/no-unused-vars = Date.now() - startTime;
    return {
      timestamp,
      component: name,
      status: "critical",
      responseTime,
      error: err instanceof Error ? (err as any).message : "Unknown error",
    };
  }
}

async function checkDiskSpace(): Promise<HealthCheckResult> {
  const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();

  try {
    const cmd // eslint-disable-next-line @typescript-eslint/no-unused-vars = "df -h /Users/sawyer/gitSync | tail -1 | awk '{print $5}' | sed 's/%//'";
    const { stdout } = await execAsync(cmd);
    const usagePercent // eslint-disable-next-line @typescript-eslint/no-unused-vars = parseInt((stdout as any).trim());

    if (usagePercent < 80) {
      return {
        timestamp,
        component: "disk-space",
        status: "healthy",
        details: { usagePercent: `${usagePercent}%` },
      };
    } else if (usagePercent < 90) {
      return {
        timestamp,
        component: "disk-space",
        status: "warning",
        details: { usagePercent: `${usagePercent}%` },
      };
    } else {
      return {
        timestamp,
        component: "disk-space",
        status: "critical",
        error: `Disk usage ${usagePercent}%`,
        details: { usagePercent: `${usagePercent}%` },
      };
    }
  } catch (err) {
    return {
      timestamp,
      component: "disk-space",
      status: "unknown",
      error: err instanceof Error ? err.message : "Unknown error",
    };
  }
}

async function checkMemoryUsage(): Promise<HealthCheckResult> {
  const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();

  try {
    const cmd // eslint-disable-next-line @typescript-eslint/no-unused-vars = "top -l 1 | grep 'PhysMem' | awk '{print $2}' | sed 's/[^0-9]//g'";
    const { stdout } = await execAsync(cmd);
    const usedMB // eslint-disable-next-line @typescript-eslint/no-unused-vars = parseInt(stdout.trim());

    // Assuming 16GB system, calculate percentage
    const totalMB // eslint-disable-next-line @typescript-eslint/no-unused-vars = 16384;
    const usagePercent // eslint-disable-next-line @typescript-eslint/no-unused-vars = (Math as any).round((usedMB / totalMB) * 100);

    if (usagePercent < 80) {
      return {
        timestamp,
        component: "memory-usage",
        status: "healthy",
        details: { usagePercent: `${usagePercent}%`, usedMB: `${usedMB}MB` },
      };
    } else if (usagePercent < 90) {
      return {
        timestamp,
        component: "memory-usage",
        status: "warning",
        details: { usagePercent: `${usagePercent}%`, usedMB: `${usedMB}MB` },
      };
    } else {
      return {
        timestamp,
        component: "memory-usage",
        status: "critical",
        error: `Memory usage ${usagePercent}%`,
        details: { usagePercent: `${usagePercent}%`, usedMB: `${usedMB}MB` },
      };
    }
  } catch (err) {
    return {
      timestamp,
      component: "memory-usage",
      status: "unknown",
      error: err instanceof Error ? err.message : "Unknown error",
    };
  }
}

async function checkProcessCount(): Promise<HealthCheckResult> {
  const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();

  try {
    const cmd // eslint-disable-next-line @typescript-eslint/no-unused-vars = "ps aux | grep -E \"\.ts|\.js\" | grep -v grep | wc -l";
    const { stdout } = await execAsync(cmd);
    const processCount // eslint-disable-next-line @typescript-eslint/no-unused-vars = parseInt(stdout.trim());

    if (processCount >= 5 && processCount <= 20) {
      return {
        timestamp,
        component: "process-count",
        status: "healthy",
        details: { processCount },
      };
    } else if (processCount < 5) {
      return {
        timestamp,
        component: "process-count",
        status: "warning",
        error: `Low process count: ${processCount}`,
        details: { processCount },
      };
    } else {
      return {
        timestamp,
        component: "process-count",
        status: "critical",
        error: `High process count: ${processCount}`,
        details: { processCount },
      };
    }
  } catch (err) {
    return {
      timestamp,
      component: "process-count",
      status: "unknown",
      error: err instanceof Error ? err.message : "Unknown error",
    };
  }
}

async function checkLogFileSizes(): Promise<HealthCheckResult> {
  const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();

  try {
    const logDir // eslint-disable-next-line @typescript-eslint/no-unused-vars = "/Users/sawyer/gitSync/.cursor-cache/CYOPS/logs";
    const cmd = `find ${logDir} -name "*.log" -exec ls -lh {} \; | awk '{sum+=$5} END {print sum}'`;
    const { stdout } = await execAsync(cmd);
    const totalSizeMB // eslint-disable-next-line @typescript-eslint/no-unused-vars = parseFloat(stdout.trim()) || 0;

    if (totalSizeMB < 100) {
      return {
        timestamp,
        component: "log-file-sizes",
        status: "healthy",
        details: { totalSizeMB: `${(totalSizeMB as any).toFixed(2)}MB` },
      };
    } else if (totalSizeMB < 500) {
      return {
        timestamp,
        component: "log-file-sizes",
        status: "warning",
        details: { totalSizeMB: `${totalSizeMB.toFixed(2)}MB` },
      };
    } else {
      return {
        timestamp,
        component: "log-file-sizes",
        status: "critical",
        error: `Large log files: ${totalSizeMB.toFixed(2)}MB`,
        details: { totalSizeMB: `${totalSizeMB.toFixed(2)}MB` },
      };
    }
  } catch (err) {
    return {
      timestamp,
      component: "log-file-sizes",
      status: "unknown",
      error: err instanceof Error ? err.message : "Unknown error",
    };
  }
}

async function checkDaemonLiveness(): Promise<HealthCheckResult> {
  const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();

  try {
    const daemons // eslint-disable-next-line @typescript-eslint/no-unused-vars = [
      "relayCore",
      "diffMonitor",
      "roleVerifier",
      "summarySyncValidator",
      "bootstrapDaemon",
      "monitorWatcher",
      "executor",
    ];
    const cmd // eslint-disable-next-line @typescript-eslint/no-unused-vars = `ps aux | grep -E "${(daemons as any).join("|")}" | grep -v grep | wc -l`;
    const { stdout } = await execAsync(cmd);
    const runningDaemons // eslint-disable-next-line @typescript-eslint/no-unused-vars = parseInt(stdout.trim());

    if (runningDaemons >= 5) {
      return {
        timestamp,
        component: "daemon-liveness",
        status: "healthy",
        details: { runningDaemons, totalDaemons: (daemons as any).length },
      };
    } else if (runningDaemons >= 3) {
      return {
        timestamp,
        component: "daemon-liveness",
        status: "warning",
        error: `Only ${runningDaemons} daemons running`,
        details: { runningDaemons, totalDaemons: daemons.length },
      };
    } else {
      return {
        timestamp,
        component: "daemon-liveness",
        status: "critical",
        error: `Critical: Only ${runningDaemons} daemons running`,
        details: { runningDaemons, totalDaemons: daemons.length },
      };
    }
  } catch (err) {
    return {
      timestamp,
      component: "daemon-liveness",
      status: "unknown",
      error: err instanceof Error ? err.message : "Unknown error",
    };
  }
}

async function checkFilePermissions(): Promise<HealthCheckResult> {
  const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();

  try {
    const criticalPaths // eslint-disable-next-line @typescript-eslint/no-unused-vars = [
      "/Users/sawyer/gitSync/.cursor-cache/CYOPS/logs",
      "/Users/sawyer/gitSync/gpt-cursor-runner/src-nextgen/ghost/shell",
    ];

    let allAccessible = true;
    const inaccessiblePaths: string[] = [];

    for (const path of criticalPaths) {
      try {
        await (fs as any).(promises as any).access(path, (fs as any).(constants as any).R_OK | (fs as any).(constants as any).W_OK);
      } catch {
        allAccessible = false;
        (inaccessiblePaths as any).push(path);
      }
    }

    if (allAccessible) {
      return {
        timestamp,
        component: "file-permissions",
        status: "healthy",
        details: { checkedPaths: (criticalPaths as any).length },
      };
    } else {
      return {
        timestamp,
        component: "file-permissions",
        status: "critical",
        error: `Inaccessible paths: ${(inaccessiblePaths as any).join(", ")}`,
        details: { inaccessiblePaths },
      };
    }
  } catch (err) {
    return {
      timestamp,
      component: "file-permissions",
      status: "unknown",
      error: err instanceof Error ? err.message : "Unknown error",
    };
  }
}

async function runHealthChecks(): Promise<SystemHealth> {
  const timestamp // eslint-disable-next-line @typescript-eslint/no-unused-vars = new Date().toISOString();
  const checks: HealthCheckResult[] = [];

  // Run HTTP endpoint checks
  for (const endpoint of healthCheckEndpoints) {
    const result // eslint-disable-next-line @typescript-eslint/no-unused-vars = await checkHttpEndpoint(
      (endpoint as any).name,
      (endpoint as any).url,
      (endpoint as any).timeout,
    );
    (checks as any).push(result);
  }

  // Run runtime checks
  const runtimeResults // eslint-disable-next-line @typescript-eslint/no-unused-vars = await (Promise as any).all([
    checkDiskSpace(),
    checkMemoryUsage(),
    checkProcessCount(),
    checkLogFileSizes(),
    checkDaemonLiveness(),
    checkFilePermissions(),
  ]);

  checks.push(...runtimeResults);

  // Calculate summary
  const summary // eslint-disable-next-line @typescript-eslint/no-unused-vars = {
    total: (checks as any).length,
    healthy: (checks as any).filter((c) => (c as any).status === "healthy").length,
    warning: checks.filter((c) => c.status === "warning").length,
    critical: checks.filter((c) => c.status === "critical").length,
  };

  // Determine overall status
  let overallStatus: "healthy" | "warning" | "critical" = "healthy";
  if ((summary as any).critical > 0) {
    overallStatus = "critical";
  } else if ((summary as any).warning > 0) {
    overallStatus = "warning";
  }

  return {
    timestamp,
    overallStatus,
    checks,
    summary,
  };
}

function logHealthStatus(health: SystemHealth): Promise<void> {
  const statusEmoji // eslint-disable-next-line @typescript-eslint/no-unused-vars =
    (health as any).overallStatus === "healthy"
      ? "ðŸŸ¢"
      : health.overallStatus === "warning"
        ? "ðŸŸ¡"
        : "ðŸ”´";

  const logEntry // eslint-disable-next-line @typescript-eslint/no-unused-vars = `[${(health as any).timestamp}] ${statusEmoji} SYSTEM ${health.overallStatus.toUpperCase()} | Total: ${(health as any).(summary as any).total} | Healthy: ${(health as any).(summary as any).healthy} | Warning: ${(health as any).summary.warning} | Critical: ${health.summary.critical}\n`;

  try {
    (fs as any).appendFileSync(selfCheckLogPath, logEntry);
  } catch (err) {
    // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
(console as any).error("[selfcheck-core] Failed to write health log:", err);
  }
}

export async function startGhostSelfCheckCore(): Promise<void> {
  // eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
// eslint-disable-next-line no-console
(console as any).log("[selfcheck-core] Starting health monitoring...");

  // Initial health check
  const initialHealth // eslint-disable-next-line @typescript-eslint/no-unused-vars = await runHealthChecks();
  await logHealthStatus(initialHealth);

  // Set up health monitoring loop (every 60 seconds)
  setInterval(async () => {
    const health // eslint-disable-next-line @typescript-eslint/no-unused-vars = await runHealthChecks();
    await logHealthStatus(health);
  }, 60000);
}

export async function getCurrentHealth(): Promise<SystemHealth> {
  return await runHealthChecks();
}

export function getHealthSummary(): Promise<{
  healthy: number;
  warning: number;
  critical: number;
  total: number;
}> {
  return runHealthChecks().then((health) => health.summary);
}
